package edu.colorado.cs.ngn.storm.reconfigurable;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.commons.codec.binary.Base64;
import org.freedesktop.dbus.DBusAsyncReply;
import org.freedesktop.dbus.DBusConnection;
import org.freedesktop.dbus.DBusSigHandler;
import org.freedesktop.dbus.exceptions.DBusException;

import backtype.storm.Config;
import backtype.storm.StormSubmitter;
import backtype.storm.generated.AlreadyAliveException;
import backtype.storm.generated.InvalidTopologyException;
import backtype.storm.spout.SpoutOutputCollector;
import backtype.storm.task.TopologyContext;
import backtype.storm.topology.OutputFieldsDeclarer;
import backtype.storm.topology.TopologyBuilder;
import backtype.storm.topology.base.BaseRichSpout;
import backtype.storm.tuple.Fields;
import edu.colorado.cs.ngn.sdipc.Switch;
import edu.colorado.cs.ngn.storm.dbus.StormTupleSignal;
import edu.colorado.cs.ngn.storm.dbus.StormTupleSignal.TupleSignal;

/**
 * This spout will sit before each "real" Storm bolt and connect to DBus.
 * All input for each "real" bolt will be received from DBus
 * TODO: make into abstract class -> cannot declare output fields 
 * after the Storm launches the object
 * @author michael
 *
 */
public class DBusReceiverSpout extends BaseRichSpout {

	/**
	 * autogenerated id
	 */
	private static final long serialVersionUID = 1L;
	private DBusReceiverTask dbusReceiver = null;
	private ConcurrentLinkedQueue<List<Object>> tupleQueue;
	private SpoutOutputCollector collector;
	private ExecutorService execService;
	public final static int SHUTDOWN_TIMEOUT = 5000;
	/**
	 * id of dbus system to connect to
	 * TODO: verify this address
	 */
	public final static String CONNECTION_ID = "edu.colorado.cs.ngn.sdipc.Switch";
	
	@Override
	public void nextTuple() {
		if(!tupleQueue.isEmpty()){
			List<Object> tuple = new ArrayList<Object>();
			tuple.add(tupleQueue.poll());
			collector.emit(tuple);
		}
	}

	@Override
	public void open(@SuppressWarnings("rawtypes") Map arg0, TopologyContext arg1, SpoutOutputCollector arg2) {
		//need to connect to DBus with some id
		tupleQueue = new ConcurrentLinkedQueue<List<Object>>();
		execService = Executors.newCachedThreadPool();
		launch_dbus_receiver();
		this.collector = arg2;
	}

	private void launch_dbus_receiver() {
		dbusReceiver = new DBusReceiverTask(this);
		execService.execute(dbusReceiver);
	}

	
	@Override
	public void close(){
		if(dbusReceiver != null){
			dbusReceiver.shutdown();
		}
		execService.shutdown();
		try {
			execService.awaitTermination(SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS);
		} catch (InterruptedException e) {
			System.out.println("Could not shutdown executor service in "+SHUTDOWN_TIMEOUT+ " ms in "+this.getClass().getCanonicalName());
		}
		super.close();
	}
	
	public static List<Object> unflattenDBusList(String objectList){
		ByteArrayInputStream bis = new ByteArrayInputStream(Base64.decodeBase64(objectList));
		ObjectInput in = null;
		List<Object> list = null;
		try {
			in = new ObjectInputStream(bis);
			list = (List<Object>) in.readObject();
		} catch (IOException e) {
			System.out.println("Could not creare ObjectInputStream");
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			System.out.println("Could not create class from byte array");
			e.printStackTrace();
		} finally{
			try {
				bis.close();
			} catch (IOException e) {}
			
			if(in != null){
				try {
					in.close();
				} catch (IOException e) {}
			}
		}
		return list;
	}
	
	public static String flattenDBusList(List<Object> objectList){
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		ObjectOutput out = null;
		byte[] objectBytes = null;
		try{
			
			out = new ObjectOutputStream(bos);
			out.writeObject(objectList);
			objectBytes = bos.toByteArray();
		} catch (IOException e) {
			System.out.println("Could not create ObjectOutputStream or write object to byte array");
			e.printStackTrace();
		} finally{
			if(out != null){
				try {
					out.close();
				} catch (IOException e) {}
			}
			try {
				bos.close();
			} catch (IOException e) {}
		}
		return Base64.encodeBase64String(objectBytes);
	}
	
	private class DBusReceiverTask implements Runnable{

		private DBusConnection connection = null;
		private AtomicBoolean boltExecuting = new AtomicBoolean(true);
		private DBusReceiverSpout receiverSpout;
		
		public DBusReceiverTask(DBusReceiverSpout receiverSpout){
			this.receiverSpout = receiverSpout;
		}
		
		@Override
		public void run() {
			try {
				connection = DBusConnection.getConnection(DBusConnection.SESSION);
			} catch (DBusException e) {
				System.out.println("Could not connect to the DBus");
				e.printStackTrace();
			}
			while(boltExecuting.get()){
				try {
					Switch dbusSwitch = connection.getRemoteObject(DBusReceiverSpout.CONNECTION_ID, "/edu/colorado/cs/ngn/sdipc/Switch", Switch.class);
//					DBusAsyncReply<String> reply = connection.callMethodAsync(dbusSwitch, "dequeue");
					String data = dbusSwitch.dequeue();
					if(data.length() > 0){
						List<Object> receivedTuple = DBusReceiverSpout.unflattenDBusList(data);
						if(receivedTuple != null){
							receiverSpout.tupleQueue.add(receivedTuple);
						}
					}
				} catch (DBusException e) {
					System.out.println("Could not get remote object: "+DBusReceiverSpout.CONNECTION_ID);
					e.printStackTrace();
				}
			}
		}

		public void shutdown() {
			boltExecuting.set(false);
			connection.disconnect();
		}
	}
	
	public static void main(String[] args) throws AlreadyAliveException, InvalidTopologyException{
		TopologyBuilder builder = new TopologyBuilder();
		
		builder.setSpout("a", new DBusReceiverSpout(), 1);
		
		builder.setBolt("b", new DBusSenderBolt(), 1).shuffleGrouping("a");
		
		Config conf = new Config();
		conf.setNumWorkers(1);
//		conf.setDebug(true);
		
		StormSubmitter.submitTopology("dbus_test_topology", conf, builder.createTopology());
	}

	@Override
	public void declareOutputFields(OutputFieldsDeclarer arg0) {
		arg0.declare(new Fields("data"));
		
	}

}
