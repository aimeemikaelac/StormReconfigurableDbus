package edu.colorado.cs.ngn.storm.reconfigurable;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.freedesktop.dbus.DBusConnection;
import org.freedesktop.dbus.DBusSigHandler;
import org.freedesktop.dbus.exceptions.DBusException;

import backtype.storm.Config;
import backtype.storm.StormSubmitter;
import backtype.storm.generated.AlreadyAliveException;
import backtype.storm.generated.InvalidTopologyException;
import backtype.storm.spout.SpoutOutputCollector;
import backtype.storm.task.TopologyContext;
import backtype.storm.topology.OutputFieldsDeclarer;
import backtype.storm.topology.TopologyBuilder;
import backtype.storm.topology.base.BaseRichSpout;
import backtype.storm.tuple.Fields;
import edu.colorado.cs.ngn.storm.dbus.StormTupleSignal;
import edu.colorado.cs.ngn.storm.dbus.StormTupleSignal.TupleSignal;

/**
 * This spout will sit before each "real" Storm bolt and connect to DBus.
 * All input for each "real" bolt will be received from DBus
 * TODO: make into abstract class -> cannot declare output fields 
 * after the Storm launches the object
 * @author michael
 *
 */
public class DBusReceiverSpout extends BaseRichSpout {

	/**
	 * autogenerated id
	 */
	private static final long serialVersionUID = 1L;
	private DBusReceiverTask dbusReceiver = null;
	private ConcurrentLinkedQueue<List<Object>> tupleQueue;
	private SpoutOutputCollector collector;
	private ExecutorService execService;
	public final static int SHUTDOWN_TIMEOUT = 5000;
	/**
	 * id of dbus system to connect to
	 * TODO: verify this address
	 */
	public final static String CONNECTION_ID = "edu.colorado.cs.ngn.sdipc.Switch";
	
//	@Override
//	public void nextTuple() {
//		// TODO Auto-generated method stub
//		
//	}

//	@Override
//	public void open(Map arg0, TopologyContext arg1, SpoutOutputCollector arg2) {
//		// TODO Auto-generated method stub
//		
//	}
	
	@Override
	public void nextTuple() {
		if(!tupleQueue.isEmpty()){
			List<Object> tuple = new ArrayList<Object>();
			tuple.add(tupleQueue.poll());
			collector.emit(tuple);
		}
	}

	@Override
	public void open(Map arg0, TopologyContext arg1, SpoutOutputCollector arg2) {
		//need to connect to DBus with some id
		tupleQueue = new ConcurrentLinkedQueue<List<Object>>();
		execService = Executors.newCachedThreadPool();
		launch_dbus_receiver();
		this.collector = arg2;
	}

	private void launch_dbus_receiver() {
		dbusReceiver = new DBusReceiverTask(this);
		execService.execute(dbusReceiver);
	}

	
	@Override
	public void close(){
		if(dbusReceiver != null){
			dbusReceiver.shutdown();
		}
		execService.shutdown();
		try {
			execService.awaitTermination(SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS);
		} catch (InterruptedException e) {
			System.out.println("Could not shutdown executor service in "+SHUTDOWN_TIMEOUT+ " ms in "+this.getClass().getCanonicalName());
		}
		super.close();
	}
	
	private class DBusReceiverTask implements Runnable{

		private DBusConnection connection = null;
//		private AtomicBoolean boltExecuting = new AtomicBoolean(true);
		private DBusReceiverSpout receiverSpout;
		
		public DBusReceiverTask(DBusReceiverSpout receiverSpout){
			this.receiverSpout = receiverSpout;
		}
		
		@Override
		public void run() {
			try {
				connection = DBusConnection.getConnection(DBusConnection.SESSION);
			} catch (DBusException e) {
				System.out.println("Could not connect to the DBus");
				e.printStackTrace();
			}
			try {
				connection.addSigHandler(StormTupleSignal.TupleSignal.class, new StormTupleSignalHandler(receiverSpout));
			} catch (DBusException e) {
				System.out.println("Could not create signal handler on DBus");
				e.printStackTrace();
			}
			
		}

		public void shutdown() {
//			boltExecuting.set(false);
			connection.disconnect();
		}
		
	}
	
	private class StormTupleSignalHandler implements DBusSigHandler<StormTupleSignal.TupleSignal>{
		private DBusReceiverSpout receiverSpout;
		
		public StormTupleSignalHandler(DBusReceiverSpout receiverSpout){
			this.receiverSpout = receiverSpout;
		}

		@Override
		public void handle(TupleSignal s) {
			byte[] objectData = s.objectData;
			int objectCount = s.objectCount;
			List<Object> objectList; //= new ArrayList<Object>();
			ByteArrayInputStream bis = new ByteArrayInputStream(objectData);
			ObjectInput in = null;
			try {
				in = new ObjectInputStream(bis);
				Object o = in.readObject();
//				objectList.add(o);
				objectList = (List<Object>) o;
//					List<Object> receivedTuple = (List<Object>) o;
//				receiverBolt.emitTuple(receivedTuple);
				receiverSpout.tupleQueue.add(objectList);
			} catch (IOException e) {
				System.out.println("Could not read object array");
				e.printStackTrace();
			} catch (ClassNotFoundException e) {
				System.out.println("Could not create object from object array");
				e.printStackTrace();
			} finally{
				try {
					bis.close();
				} catch (IOException e) {}
				
				if(in != null){
					try {
						in.close();
					} catch (IOException e) {}
				}
			}
			
		}
		
	}
	
	public static void main(String[] args) throws AlreadyAliveException, InvalidTopologyException{
		TopologyBuilder builder = new TopologyBuilder();
		
		builder.setSpout("a", new DBusReceiverSpout(), 1);
		
		builder.setBolt("b", new DBusSenderBolt(), 1).shuffleGrouping("a");
		
		Config conf = new Config();
		conf.setNumWorkers(1);
		conf.setDebug(true);
		
		StormSubmitter.submitTopology("dbus_test_topology", conf, builder.createTopology());
	}

	@Override
	public void declareOutputFields(OutputFieldsDeclarer arg0) {
		arg0.declare(new Fields("data"));
		
	}

}
