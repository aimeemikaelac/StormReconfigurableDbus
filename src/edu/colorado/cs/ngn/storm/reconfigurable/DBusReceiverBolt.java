package edu.colorado.cs.ngn.storm.reconfigurable;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.freedesktop.dbus.DBusConnection;
import org.freedesktop.dbus.DBusSigHandler;
import org.freedesktop.dbus.exceptions.DBusException;

import backtype.storm.task.OutputCollector;
import backtype.storm.task.TopologyContext;
import backtype.storm.topology.OutputFieldsDeclarer;
import backtype.storm.topology.base.BaseRichBolt;
import backtype.storm.tuple.Tuple;
import edu.colorado.cs.ngn.storm.dbus.DBusStormTuple;
import edu.colorado.cs.ngn.storm.dbus.StormTupleSignal;
import edu.colorado.cs.ngn.storm.dbus.StormTupleSignal.TupleSignal;

/**
 * This bolt will sit before each "real" Storm bolt and connect to DBus.
 * All input for each "real" bolt will be received from DBus
 * TODO: make into abstract class -> cannot declare output fields 
 * after the Storm launches the object
 * TODO: may be necessary to convert to Spout, as Bolt may never
 * be created if it does not subscribe to tuples using Storm's mechanisms.
 * Also would allow for queries to be sent to DBus on when tuples are
 * requested by Storm 
 * @author michael
 *
 */
public class DBusReceiverBolt extends BaseRichBolt {

	/**
	 * autogenerated id
	 */
	private static final long serialVersionUID = 1L;
	private DBusReceiverTask dbusReceiver = null;
	private OutputCollector collector;
	private ExecutorService execService;
	public final static int SHUTDOWN_TIMEOUT = 5000;
	/**
	 * id of dbus system to connect to
	 * TODO: verify this address
	 */
	public final static String CONNECTION_ID = "edu.colorado.cs.ngn.sdipc.Switch";

	@Override
	public void execute(Tuple arg0) {
		emitTuple(arg0);
	}

	private void emitTuple(Tuple arg0) {
		collector.emit(arg0.getValues());
	}

	@Override
	public void prepare(Map arg0, TopologyContext arg1, OutputCollector arg2) {
		//need to connect to DBus with some id
		launch_dbus_receiver();
		this.collector = arg2;
		execService = Executors.newCachedThreadPool();
	}

	private void launch_dbus_receiver() {
		dbusReceiver = new DBusReceiverTask(this);
		execService.execute(dbusReceiver);
	}

	@Override
	public void declareOutputFields(OutputFieldsDeclarer arg0) {
		// TODO Auto-generated method stub

	}
	
	@Override
	public void cleanup(){
		if(dbusReceiver != null){
			dbusReceiver.shutdown();
		}
		execService.shutdown();
		try {
			execService.awaitTermination(SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS);
		} catch (InterruptedException e) {
			System.out.println("Could not shutdown executor service in "+SHUTDOWN_TIMEOUT+ " ms in DBusReceiverBolt");
		}
		super.cleanup();
	}
	
	private class DBusReceiverTask implements Runnable{

		private DBusConnection connection = null;
//		private AtomicBoolean boltExecuting = new AtomicBoolean(true);
		private DBusReceiverBolt receiverBolt;
		
		public DBusReceiverTask(DBusReceiverBolt receiverBolt){
			this.receiverBolt = receiverBolt;
		}
		
		@Override
		public void run() {
			try {
				connection = DBusConnection.getConnection(DBusConnection.SESSION);
			} catch (DBusException e) {
				System.out.println("Could not connect to the DBus");
				e.printStackTrace();
			}
			try {
				connection.addSigHandler(StormTupleSignal.TupleSignal.class, new StormTupleSignalHandler(receiverBolt));
			} catch (DBusException e) {
				System.out.println("Could not create signal handler on DBus");
				e.printStackTrace();
			}
			
		}

		public void shutdown() {
//			boltExecuting.set(false);
			connection.disconnect();
		}
		
	}
	
	private class StormTupleSignalHandler implements DBusSigHandler<StormTupleSignal.TupleSignal>{
		private DBusReceiverBolt receiverBolt;
		
		public StormTupleSignalHandler(DBusReceiverBolt receiverBolt){
			this.receiverBolt = receiverBolt;
		}

		@Override
		public void handle(TupleSignal s) {
			byte[] objectData = s.objectData;
			ByteArrayInputStream bis = new ByteArrayInputStream(objectData);
			ObjectInput in = null;
			try {
				in = new ObjectInputStream(bis);
				Object o = in.readObject();
				Tuple receivedTuple = (Tuple) o;
				receiverBolt.emitTuple(receivedTuple);
			} catch (IOException e) {
				System.out.println("Could not read object array");
				e.printStackTrace();
			} catch (ClassNotFoundException e) {
				System.out.println("Could not create object from object array");
				e.printStackTrace();
			} finally{
				try {
					bis.close();
				} catch (IOException e) {}
				
				if(in != null){
					try {
						in.close();
					} catch (IOException e) {}
				}
			}
		}
		
	}

}
